// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import "forge-std/Test.sol";
import "../src/core/DotHypeRegistry.sol";
import "../src/core/DotHypeController.sol";
import "./mocks/MockPriceOracle.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract DotHypeMerkleMintTest is Test {
    using stdStorage for StdStorage;

    DotHypeRegistry public registry;
    DotHypeController public controller;
    MockPriceOracle public priceOracle;

    address public owner = address(0x1);
    address public signer = address(0x2);
    address public user1 = address(0x3);
    address public user2 = address(0x4);
    address public user3 = address(0x5);
    address public user4 = address(0x6);
    address public attacker = address(0x7);

    // Merkle tree-related variables
    // These values were generated by the scripts/generate-merkle-proofs.js script
    bytes32 public merkleRoot = 0x62f58a519db2536f6bd8ce1c4d85790fea9cd3a236572908a247e6af6dede71d;
    mapping(address => bytes32[]) public proofs;

    // Mock price parameters
    uint64 constant INITIAL_PRICE = 2000000; // $2.00 (scaled by 1e6)
    uint256 constant SCALE = 1e6;

    // Helper function to convert USD to HYPE
    function convertUsdToHype(uint256 usdAmount) internal pure returns (uint256) {
        return (usdAmount * SCALE) / INITIAL_PRICE;
    }

    // Setup before each test
    function setUp() public {
        // Deploy mock price oracle
        priceOracle = new MockPriceOracle(INITIAL_PRICE);

        // Deploy registry and controller
        registry = new DotHypeRegistry(owner, address(this));
        controller = new DotHypeController(address(registry), signer, address(priceOracle), owner);

        // Set controller in registry
        vm.prank(owner);
        registry.setController(address(controller));

        // Set annual prices for different character counts
        uint256[5] memory prices = [
            type(uint256).max, // 1 character: extremely high price (effectively unavailable)
            type(uint256).max, // 2 characters: extremely high price (effectively unavailable)
            100 ether, // 3 characters: $100 per year
            10 ether, // 4 characters: $10 per year
            1 ether // 5+ characters: $1 per year
        ];

        vm.prank(owner);
        controller.setAllAnnualPrices(prices);

        // Ensure payment recipient is set to owner
        vm.prank(owner);
        controller.setPaymentRecipient(owner);
        
        // Setup pre-computed merkle proofs for each address
        setupMerkleProofs();
        
        // Set the Merkle root in the controller
        vm.prank(owner);
        controller.setMerkleRoot(merkleRoot);
    }

    // Setup pre-computed merkle proofs
    function setupMerkleProofs() internal {
        // These proofs were generated by scripts/generate-merkle-proofs.js
        
        // Proof for user1 (address(0x3))
        bytes32[] memory user1Proof = new bytes32[](2);
        user1Proof[0] = 0xa876da518a393dbd067dc72abfa08d475ed6447fca96d92ec3f9e7eba503ca61;
        user1Proof[1] = 0x421df1fa259221d02aa4956eb0d35ace318ca24c0a33a64c1af96cf67cf245b6;
        proofs[user1] = user1Proof;

        // Proof for user2 (address(0x4))
        bytes32[] memory user2Proof = new bytes32[](2);
        user2Proof[0] = 0x5b70e80538acdabd6137353b0f9d8d149f4dba91e8be2e7946e409bfdbe685b9;
        user2Proof[1] = 0x421df1fa259221d02aa4956eb0d35ace318ca24c0a33a64c1af96cf67cf245b6;
        proofs[user2] = user2Proof;

        // Proof for user3 (address(0x5))
        bytes32[] memory user3Proof = new bytes32[](1);
        user3Proof[0] = 0x735c77c52a2b69afcd4e13c0a6ece7e4ccdf2b379d39417e21efe8cd10b5ff1b;
        proofs[user3] = user3Proof;
    }

    // Test successful Merkle proof minting
    function testMerkleProofMinting() public {
        string memory name = "merkletest";
        uint256 duration = 365 days;
        
        // Calculate price
        uint256 price = controller.calculatePrice(name, duration);
        
        // Fund user1
        vm.deal(user1, price);
        
        // Attempt to mint with merkle proof as user1
        vm.prank(user1);
        (uint256 tokenId, uint256 expiry) = controller.registerWithMerkleProof{value: price}(
            name, 
            duration, 
            proofs[user1]
        );
        
        // Verify registration
        assertEq(registry.ownerOf(tokenId), user1);
        assertEq(expiry, block.timestamp + duration);
        
        // Verify the user is marked as having used their proof
        assertTrue(controller.hasAddressUsedMerkleProof(user1));
    }
    
    // Test that non-whitelisted user can't mint
    function testNonWhitelistedMinting() public {
        string memory name = "notwhitelisted";
        uint256 duration = 365 days;
        
        // Calculate price
        uint256 price = controller.calculatePrice(name, duration);
        
        // Fund user4 (not in whitelist)
        vm.deal(user4, price);
        
        // Create a fake proof
        bytes32[] memory fakeProof = new bytes32[](1);
        fakeProof[0] = bytes32(0);
        
        // Attempt to mint with fake merkle proof
        vm.prank(user4);
        vm.expectRevert(DotHypeController.InvalidMerkleProof.selector);
        controller.registerWithMerkleProof{value: price}(
            name, 
            duration, 
            fakeProof
        );
    }
    
    // Test that one whitelisted user can't use another's proof
    function testWrongProofMinting() public {
        string memory name = "wrongproof";
        uint256 duration = 365 days;
        
        // Calculate price
        uint256 price = controller.calculatePrice(name, duration);
        
        // Fund user2
        vm.deal(user2, price);
        
        // Attempt to mint with user1's proof
        vm.prank(user2);
        vm.expectRevert(DotHypeController.InvalidMerkleProof.selector);
        controller.registerWithMerkleProof{value: price}(
            name, 
            duration, 
            proofs[user1]
        );
    }
    
    // Test that attempting to register a reserved name fails
    function testReservedNameMerkleMinting() public {
        string memory name = "reserved";
        uint256 duration = 365 days;
        
        // Reserve the name for a different address
        vm.prank(owner);
        controller.setReservation(name, user4);
        
        // Calculate price
        uint256 price = controller.calculatePrice(name, duration);
        
        // Fund user1
        vm.deal(user1, price);
        
        // Attempt to mint reserved name
        vm.prank(user1);
        vm.expectRevert(abi.encodeWithSelector(
            DotHypeController.NameIsReserved.selector, 
            keccak256(bytes(name)), 
            user4
        ));
        controller.registerWithMerkleProof{value: price}(
            name, 
            duration, 
            proofs[user1]
        );
        
        // Verify that the owner of the reserved name can mint it
        vm.deal(user4, price);
        bytes32[] memory fakeProof = new bytes32[](1);
        fakeProof[0] = bytes32(0);
        
        // Even though user4 isn't in the merkle tree, they should be able to use registerReserved
        vm.prank(user4);
        (uint256 tokenId, ) = controller.registerReserved{value: price}(name, duration);
        
        // Verify registration was successful
        assertEq(registry.ownerOf(tokenId), user4);
    }
    
    // Test that a user can only mint one domain with their proof
    function testCannotMintMultipleDomainsWithSameProof() public {
        string memory name1 = "firstdomain";
        string memory name2 = "seconddomain";
        uint256 duration = 365 days;
        
        // Calculate price
        uint256 price = controller.calculatePrice(name1, duration);
        
        // Fund user1 with enough for two registrations
        vm.deal(user1, price * 2);
        
        // First mint
        vm.prank(user1);
        controller.registerWithMerkleProof{value: price}(
            name1, 
            duration, 
            proofs[user1]
        );
        
        // Verify the user is marked as having used their proof
        assertTrue(controller.hasAddressUsedMerkleProof(user1));
        
        // Try to mint a second domain - should fail with AlreadyMinted error
        vm.prank(user1);
        vm.expectRevert(abi.encodeWithSelector(
            DotHypeController.AlreadyMinted.selector,
            user1
        ));
        controller.registerWithMerkleProof{value: price}(
            name2, 
            duration, 
            proofs[user1]
        );
    }
    
    // Test the reset functionality for merkle proof usage
    function testResetMerkleProofUsage() public {
        string memory name1 = "firstdomain";
        string memory name2 = "afterreset";
        uint256 duration = 365 days;
        
        // Calculate price
        uint256 price = controller.calculatePrice(name1, duration);
        
        // Fund user1 with enough for two registrations
        vm.deal(user1, price * 2);
        
        // First mint
        vm.prank(user1);
        (uint256 tokenId1,) = controller.registerWithMerkleProof{value: price}(
            name1, 
            duration, 
            proofs[user1]
        );
        
        // Verify the user is marked as having used their proof
        assertTrue(controller.hasAddressUsedMerkleProof(user1));
        
        // Reset merkle proof usage for user1
        address[] memory usersToReset = new address[](1);
        usersToReset[0] = user1;
        
        vm.prank(owner);
        controller.resetMerkleProofUsage(usersToReset);
        
        // Verify the user is no longer marked as having used their proof
        assertFalse(controller.hasAddressUsedMerkleProof(user1));
        
        // Try to mint a second domain - should succeed now
        vm.prank(user1);
        (uint256 tokenId2,) = controller.registerWithMerkleProof{value: price}(
            name2, 
            duration, 
            proofs[user1]
        );
        
        // Verify the second domain was registered to user1
        assertEq(registry.ownerOf(tokenId2), user1);
    }
    
    // Test that non-owner cannot set the merkle root
    function testNonOwnerCannotSetMerkleRoot() public {
        bytes32 newMerkleRoot = bytes32(uint256(1234));
        
        // Attempt to set merkle root as non-owner
        vm.prank(attacker);
        vm.expectRevert(abi.encodeWithSelector(
            Ownable.OwnableUnauthorizedAccount.selector,
            attacker
        ));
        controller.setMerkleRoot(newMerkleRoot);
        
        // Verify merkle root was not changed
        assertEq(controller.merkleRoot(), merkleRoot);
    }
    
    // Test that non-owner cannot reset merkle proof usage
    function testNonOwnerCannotResetMerkleProofUsage() public {
        // First have user1 mint to set hasUsedMerkleProof to true
        string memory name = "testreset";
        uint256 duration = 365 days;
        uint256 price = controller.calculatePrice(name, duration);
        
        vm.deal(user1, price);
        vm.prank(user1);
        controller.registerWithMerkleProof{value: price}(
            name, 
            duration, 
            proofs[user1]
        );
        
        // Verify user1 has used their proof
        assertTrue(controller.hasAddressUsedMerkleProof(user1));
        
        // Create array with user1
        address[] memory usersToReset = new address[](1);
        usersToReset[0] = user1;
        
        // Attempt to reset as non-owner
        vm.prank(attacker);
        vm.expectRevert(abi.encodeWithSelector(
            Ownable.OwnableUnauthorizedAccount.selector,
            attacker
        ));
        controller.resetMerkleProofUsage(usersToReset);
        
        // Verify user1 is still marked as having used their proof
        assertTrue(controller.hasAddressUsedMerkleProof(user1));
    }
    
    // Test that properly reserved name can be minted by the reserved address even if not in merkle tree
    function testReservedNameCanBeRegisteredByReservedAddress() public {
        string memory name = "exclusivename";
        uint256 duration = 365 days;
        
        // Reserve the name for user4 (who is not in the merkle tree)
        vm.prank(owner);
        controller.setReservation(name, user4);
        
        // Calculate price
        uint256 price = controller.calculatePrice(name, duration);
        
        // Fund user4
        vm.deal(user4, price);
        
        // Test that user4 cannot use registerWithMerkleProof (not in merkle tree)
        bytes32[] memory fakeProof = new bytes32[](1);
        fakeProof[0] = bytes32(0);
        
        vm.prank(user4);
        vm.expectRevert(DotHypeController.InvalidMerkleProof.selector);
        controller.registerWithMerkleProof{value: price}(
            name, 
            duration, 
            fakeProof
        );
        
        // But they can use registerReserved since the name is reserved for them
        vm.prank(user4);
        (uint256 tokenId, ) = controller.registerReserved{value: price}(name, duration);
        
        // Verify registration was successful
        assertEq(registry.ownerOf(tokenId), user4);
        
        // Verify reservation was cleared
        (bool isReserved, address reservedFor) = controller.checkReservation(name);
        assertFalse(isReserved);
        assertEq(reservedFor, address(0));
    }
} 